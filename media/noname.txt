Array
Нумерация начинается с 0, значения только одного типа
var emptyArray = String[]()
var emptyArray: String[] = []
var emptyArray: String[] = String[]()
var emptyArray: [String] = [«One», «Two», «Three»]
var shoppingList = ["рыба", "вода", "лимон"]

var newName = shoppingList[0]						// первая позиция в массиве
shoppingList[1] = "бутылка воды"           					    // обновление массива
shoppingList.count                       						      // длина массива (3)
shoppingList.append("яйца")
shoppingList += "молоко"

name = names.removeAtIndex(5)						// удалить один элемент
names.insert(«anyText», atIndex: 1)					// добавить на место первого, сдвинуть
var fibList = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 5]
fibList[4..6] 								// [3, 5] Последнее значение диапазона не входит
fibList[0..fibList.endIndex] 						// все, кроме последнего элемента
Array(fibList[0..4])

Set
Каждое значение уникальное, без ключей как словари и нумерации как в массиве, только одного типа
var number = Set<Int>()
var number: Set<Int> = []
var number: Set = [1,2,3,4,5]

let odds: Set = [1,3,5,7,9]
let evens: Set = [2,4,6,8,10]
let primes: Set = [2,3,5,7]
var union = odds.union(evens)						// [1 - 10]
var intersect = odds.intersect(evens)					// []
var subtract = odds.intersect(primes)					// [1, 9]
var xor = odds.exclusiveOr(primes)					// [1, 2, 9]

Dictionary
Уникальные ключи только одного типа, любой контент в value только одного типа
var emptyDictionary = Dictionary<String, Float>()
var ages = [String: Int]()

var occupations = [
    "Malcolm": "Captain",
    "kaylee": "Mechanic"
]
occupations["Jayne"] = "Public Relations"					// добавить значение
occupations = [:]								// обнулить словарь

Tuple
Любые типы данных в одном блоке, индексация как в массивах
let anyName = (12345, «anyName»)
let id = anyName.1							// доступ к первому значению
let (id, name) = anyName							// создание паттерна для доступа к данных
let (_, name) = anyName							// создание паттерна, игнорируем переменные
let anyName = (id: 12345, name: «anyName»)
anyName.id								// доступ к первой переменной

Управление потоком
if let number = val where val > 0 {						// дополнительная проверка
}					

let myArray = [1, 1, 2, 3, 5] 						// цикл (массив)
for value in myArray {
    if value == 1 { } else { }
}

var dict = ["name": "Steve Jobs",  "company": "Apple"]			// цикл (словарь)
for (key, value) in dict {print("\(key): \(value)")}

for i in -1...1 { }								// цикл (диапазон)

for _ in 1...3 { }						// игнорируется текущее значение диапазона при каждой итерации

var i = 1									// Цикл while
while i < 1000 { i *= 2 }

repeat { } while 1 == 2							// Цикл repeat-while

let vegetable = "red pepper"						// Switch
switch vegetable {
case "celery":
    let vegetableComment = "Add some"
case "cucumber", "watercress":
    let vegetableComment = "That would"
case let x where x.hasSuffix("pepper"):
    let vegetableComment = "Is it a spicy \(x)?"
default:
    let vegetableComment = "Everything tastes"
}

Pattern matching
let emp = (id: 12345, name: «anyName»)
switch emp {
   case (1...123456, _):						// смотрим диапазон id, игнорируем имя
      print(«some info»)
   case (_ , _):							// аналогог default, все остальные варианты тут
      print(«some info»)
}

Available
if #available (iOS 9.1, *){						// все версии до указанной
   print(«some text»)
} else {
   print(«some text»)
}

Error handling
enum MyErrorListAnyName: ErrorType {
   case DivByZero							// инициализируем события, любые имена
   case DivByOne
}

func divide(firstValue first: Int, secondValue second: Int ) throws → Double{
   if second == 0 {
      throw MyErrorListAnyName.DivByZero				// создаем «событие» если условие выполнено
   } else if second == 1 { 
      throw MyErrorListAnyName.DivByOne
}
   return Double(first) / Double(second)
}

do {
   var result = try divide(firstValue: 5, secondValue: 2)
} catch MyErrorListAnyName.DivByZero {				// ловим событие
   print(«you cannot devide by zero»)
} catch MyErrorListAnyName.DivByOne {
   print(«you cannot devide by one»)
} catch {
  // catch all errors
}

Guard
func doSomthing (val1: Int?, val2: Int?){				
   guard let number = val1 where val 1 > 0 else { return }		// создаем константу если условия выполнены
   guard let key = val2 where val 2 < 0 else { return }			// return если условие не выполнено, переходим дальше
   var aswer = number + key					// нет ограничений видимости переменных, как в if else
}

Функции
func greet(name: String, day: String) -> String {}
greet("Bob", day: "Tuesday")

func greet(externalName internalName: String, externalNameDate internalNameDate: String) -> String {return "Hello \(internalName), today is \(internalNameDate)."}
greet(externalName: "Bob", externalNameDate: "Tuesday")

func gasPrices(x: Int, y: Int = 0) -> (Int) {}						// дефолтные значения

func getGasPrices() -> (Double, Double, Double) {}					// кортеж из нескольких элементов

func getGasPrices() -> (a: Double, b: Double, c: Double) {}
let prices = getGasPrices()
print(prices.a)

func setup(numbers: Int...) {}							// принимает числа и собирает их в массив

func myFunction (name: String, age: Int) {}
var function: (String, Int) → () = myFunction					// явное указание function type

func sayHello(name: String) → String {return «Hello, \(name)»}
func useFunction(function: (String) → (String)){print(function(«anyName»))}
func returnFunction() → (String) → (String){return sayHello}
var greet = sayHello
useFunction(greet)

func printWelcomeMessage() -> String {						// вложенные функции
    var y = "Hello"
    func add(){y += " world"}
    add()
    return y
}
printWelcomeMessage()


Замыкания

Классы
Все методы и свойства классов публичны. Если вам нужно сохранить данные в структурированном объекте, то используйте конструкцию struct
// Родительский класс для Square
class Shape {
    init() {
    }
    func getArea() -> Int {
        return 0;
    }
}
// Просто класс `Square`, который наследуется от `Shape`
class Square: Shape {
    var sideLength: Int

    // getter и setter пользовательских свойств
    var perimeter: Int {
        get {
            return 4 * sideLength
        }
        set {
            sideLength = newValue / 4
        }
    }
    init(sideLength: Int) {
        self.sideLength = sideLength
        super.init()
    }

    func shrink() {
        if sideLength > 0 {
            --sideLength
        }
    }

    override func getArea() -> Int {
        return sideLength * sideLength
    }
}
var mySquare = Square(sideLength: 5)
print(mySquare.getArea()) // 25
mySquare.shrink()
print(mySquare.sideLength) // 4

// Получаем доступ к объекту класса Square,
// это эквивалентно [Square class] в Objective-C.
Square.self

//пример 'willSet' и 'didSet'
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            println("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue  {
                println("Added \(totalSteps - oldValue) steps to 'totalSteps'")
            }
        }
    }
}
var stepCounter = StepCounter()
stepCounter.totalSteps = 100 // About to set totalSteps to 100 \n Added 100 steps to 'totalSteps'
stepCounter.totalSteps = 145 // About to set totalSteps to 145 \n Added 45 steps to 'totalSteps'

// Если вам не нужны пользовательские геттеры и сеттеры, но нужно запустить код 
// до и после получения и установки свойств вы можете использовать `willSet` и `didSet`

Перечисления (Enums)
enum Suit {
    case Spades, Hearts, Diamonds, Clubs
    func getIcon() -> String {
        switch self {
        case .Spades: return "♤"
        case .Hearts: return "♡"
        case .Diamonds: return "♢"
        case .Clubs: return "♧"
        }
    }
}

Протоколы
Протокол определяет список методов, свойств и других требований, которые подходят конкретной задаче.
protocol SomeProtocol { 
// определение протокола 
}

Расширения
Добавляют новую функциональность уже созданным типам
// добавляем методы first и rest для массивов
extension Array {
    func first () -> Any? {
        return self[0]
    }
    func rest () -> Array {
        if self.count >= 1 {
            return Array(self[1..self.endIndex])
        } else {
            return []
        }
    }
}

Переопределение операторов
Вы можете перезаписать существующие операторы или создать новые для любых типов данных.
// Перезаписываем существующий оператор "+"
@infix func + (a: Int, b: Int) -> Int {
    return a - b
}
var x = 5 + 4 // x is 1
	
Добавляем оператор для нового типа данных
struct Vector2D {
    var x = 0.0, y = 0.0
}
@infix func + (left: Vector2D, right: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y + right.y)
}
	
Вам нужно использовать @assignment , если вы хотите переопределить составные операторы, такие как +=, ++ или -=”
@assignment func += (inout left: Vector2D, right: Vector2D) {
    left = left + right
}
	
Примечания:
    Вы не можете перезаписать оператор присвоения “=”.
    Операторы могут быть prefix, infix или postfix.
    Переопределение операторов ограничено следующими символами: / = – + * % < > ! & | ^ . ~

Дженерики
Дженерики позволяют написать гибкие и многократно используемые функции и типы, которые могут работать с любыми данными.
// Дженерик-функция, которая меняет два любых значения
func swapTwoValues<T>(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}

// Общий тип коллекции под названием `Stack`
struct Stack<T> {
    var elements = T[]()
    mutating func push(element: T) {
        elements.append(element)
    }
    mutating func pop() -> T {
        return elements.removeLast()
    }
}

Мы можем накладывать ограничения на типы данных в общих функциях и родовых типах. Используйте “where” после имени типа данных для указания списка требований.
// Общая функция, которая проверяет, содержит ли последовательность определённое значение.
func containsValue<
    T where T: Sequence, T.GeneratorType.Element: Equatable>
    (sequence: T, valueToFind: T.GeneratorType.Element) -> Bool {

    for value in sequence {
        if value == valueToFind {
            return true
        }
    }

    return false
}
	
****************************

http://www.nyxdata.com/Data-Products/Historical-Data
http://www.nasdaqdod.com/NASDAQAnalytics.asmx?op=GetEndOfDayData

https://www.firebase.com/
https://cocoapods.org/
https://jsonformatter.curiousconcept.com/
http://appicontemplate.com/
https://thenounproject.com/
http://www.google.ru/design/spec/material-design/introduction.html

http://geektimes.ru/post/257816/
http://www.instructables.com/id/simple-user-adjustable-DIY-Nixie-Clock/

http://tumen.mir-repetitorov.ru (sergey.melentyev@gmail.com / 10299005)
http://tumen.high-ball.ru (sergey.melentyev@gmail.com / ced2bfd1)
http://tyumen.teacherguild.ru (http://tyumen.teacherguild.ru/teacher/540)
http://tyumen.repetitors.info
http://www.utmn.ru/o-tyumgu/prepodavateli-i-sotrudniki/94206/
http://mosobr.com/
